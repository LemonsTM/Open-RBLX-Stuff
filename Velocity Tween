local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

local TIMEOUT = 10
local ACCELERATION_RATE = 5

local function isTerrain(part)
	return part:IsA("Terrain")
end

local function getDynamicAngles(characterOrientation, targetDirection)
	local relativeAngle = math.deg(math.acos(characterOrientation:Dot(targetDirection)))
	local angles = {relativeAngle, relativeAngle + 45, relativeAngle - 45, relativeAngle + 90, relativeAngle - 90}
	return angles
end

function TeleportSystem.new(config)
	local self = setmetatable({}, TeleportSystem)
	self.queue = {}
	self.isTeleporting = false
	self.currentConnection = nil
	self.onDestinationReached = Instance.new("BindableEvent")
	self.retryCount = 0
	self.lastPosition = Vector3.new()
	self.maxHeightAboveGround = 15
	self.targetWaypoint = nil
	self.currentSpeed = 0
	self.RAYCAST_DISTANCE = 50
	self.RAYCAST_ANGLES = {0, 45, -45, 90, -90, 135, -135, 180, -180}
	self.previousWaypoints = {}
	self.startTime = tick()
	return self
end

function TeleportSystem:ProbeAroundObstacle(position, endPos)
	local bestDirection = nil
	local smallestDistanceToTarget = math.huge
	local dynamicAngles = getDynamicAngles((endPos - position).Unit, self.targetWaypoint - position)
	for _, angle in ipairs(dynamicAngles) do
		local newDirection = CFrame.fromEulerAnglesXYZ(0, math.rad(angle), 0) * (endPos - position).Unit
		local ray = Ray.new(position, newDirection * self.RAYCAST_DISTANCE)
		local hit, hitPosition = workspace:FindPartOnRay(ray)

		if not hit or isTerrain(hit) then
			local distanceToTargetFromHit = (endPos - hitPosition).Magnitude
			if distanceToTargetFromHit < smallestDistanceToTarget then
				smallestDistanceToTarget = distanceToTargetFromHit
				bestDirection = newDirection
			end
		end
	end
	return bestDirection
end

function TeleportSystem:CalculateDynamicPath(startPos, endPos, stayOnGround)
	local waypoints = {endPos}
	local currentPosition = startPos

	while (currentPosition - endPos).Magnitude > 1 do
		task.wait()
		local direction = (endPos - currentPosition).Unit
		local ray = Ray.new(currentPosition, direction * self.RAYCAST_DISTANCE)
		local hit, hitPosition = workspace:FindPartOnRay(ray)

		if hit then
			local bestDirection = self:ProbeAroundObstacle(hitPosition, endPos)
			if bestDirection then
				local newWaypoint = hitPosition + bestDirection * 5
				if stayOnGround and bestDirection.Y == 0 then
					newWaypoint = Vector3.new(newWaypoint.X, currentPosition.Y, newWaypoint.Z)
				end

				local groundRay = Ray.new(newWaypoint, Vector3.new(0, -1, 0) * self.maxHeightAboveGround)
				local groundHit, groundPosition = workspace:FindPartOnRay(groundRay)
				if groundHit then
					local heightAboveGround = newWaypoint.Y - groundPosition.Y
					if heightAboveGround > self.maxHeightAboveGround then
						newWaypoint = Vector3.new(newWaypoint.X, groundPosition.Y + self.maxHeightAboveGround, newWaypoint.Z)
					end
				end

				table.insert(waypoints, 1, newWaypoint)
				currentPosition = newWaypoint
			else
				break
			end
		else
			currentPosition = currentPosition + direction * 5
		end
	end

	return waypoints
end

function TeleportSystem:isSafeDestination(destination)
	local ray = Ray.new(destination, Vector3.new(0, -1, 0) * self.maxHeightAboveGround)
	local hit = workspace:FindPartOnRay(ray)
	return not hit or isTerrain(hit)
end

function TeleportSystem:TeleportTo(position, speed, stayOnGround)
	if not self:isSafeDestination(position) then
		warn("Unsafe destination!")
		return
	end

	table.insert(self.queue, {position, speed, stayOnGround})
	if not self.isTeleporting then
		self:ProcessQueue()
	end
end

function TeleportSystem:ProcessQueue()
	if #self.queue == 0 then
		return
	end

	table.sort(self.queue, function(a, b)
		return (a[1] - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude < 
			(b[1] - game.Players.LocalPlayer.Character.HumanoidRootPart.Position).Magnitude
	end)

	local data = table.remove(self.queue, 1)
	local position, speed, stayOnGround = unpack(data)

	if tick() - self.startTime > TIMEOUT then
		self:Cancel()
		warn("Pathfinding timed out!")
		return
	end

	if self.isStuck then
		local lastWaypoint = table.remove(self.previousWaypoints)
		if lastWaypoint then
			self.targetWaypoint = lastWaypoint
		end
	end

	if self.isTeleporting then
		self.targetWaypoint = position
		return
	end

	self.isTeleporting = true
	self.targetWaypoint = position

	local character = game.Players.LocalPlayer.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	local waypoints = self:CalculateDynamicPath(humanoidRootPart.Position, position, stayOnGround)
	local currentWaypointIndex = 1

	if not self.currentConnection then
		self.currentConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
			task.wait(dt)
			if currentWaypointIndex > #waypoints then
				self.isTeleporting = false
				if self.currentConnection then
					self.currentConnection:Disconnect()
					self.currentConnection = nil
				end
				self.onDestinationReached:Fire()
				self:ProcessQueue()
				return
			end

			local waypoint = waypoints[currentWaypointIndex]
			local direction = (waypoint - humanoidRootPart.Position).Unit

			if self.currentSpeed < speed then
				self.currentSpeed = self.currentSpeed + ACCELERATION_RATE * dt
				if self.currentSpeed > speed then
					self.currentSpeed = speed
				end
			end

			humanoidRootPart.Velocity = direction * self.currentSpeed

			if (humanoidRootPart.Position - waypoint).Magnitude < 1 then
				currentWaypointIndex = currentWaypointIndex + 1
			end
		end)
	end
end

function TeleportSystem:Cancel()
	if self.currentConnection then
		self.currentConnection:Disconnect()
		self.currentConnection = nil
	end
	self.isTeleporting = false
	self.queue = {}
end

return TeleportSystem
