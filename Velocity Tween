local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local RAY_LENGTH = 50

local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

function TeleportSystem.new()
	local self = setmetatable({}, TeleportSystem)
	self.targetPosition = Vector3.new()
	self.connection = nil
	self.queue = {}
	self.stayOnGround = false
	self.onDestinationReached = Instance.new("BindableEvent")
	return self
end

function TeleportSystem:ChooseDirection(initialDirection)
	local humanoidRootPart = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
	local directions = {Vector3.new(1,0,0), Vector3.new(-1,0,0), Vector3.new(0,0,1), Vector3.new(0,0,-1)}

	for _, dir in ipairs(directions) do
		local ray = Ray.new(humanoidRootPart.Position, dir * RAY_LENGTH)
		local hit, _ = Workspace:FindPartOnRay(ray, game.Players.LocalPlayer.Character)

		if not hit then
			return dir
		end
	end

	return initialDirection
end

function TeleportSystem:TeleportTo(position, speed, stayOnGround)
	stayOnGround = stayOnGround or false
	local humanoidRootPart = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")

	if stayOnGround then
		position = Vector3.new(position.X, humanoidRootPart.Position.Y, position.Z)
	end

	table.insert(self.queue, {position = position, speed = speed, stayOnGround = stayOnGround})

	if #self.queue == 1 then
		self:ProcessQueue()
	end
end

function TeleportSystem:ProcessQueue()
	if #self.queue == 0 then return end

	local request = self.queue[1]
	self.targetPosition = request.position
	self.stayOnGround = request.stayOnGround
	local humanoidRootPart = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")

	local function onStep()
		local direction = (self.targetPosition - humanoidRootPart.Position).Unit

		if self.stayOnGround then
			direction = Vector3.new(direction.X, 0, direction.Z).Unit
		end

		local ray = Ray.new(humanoidRootPart.Position, direction * RAY_LENGTH)
		local hit, _ = Workspace:FindPartOnRay(ray, game.Players.LocalPlayer.Character)

		if hit then
			direction = self:ChooseDirection(direction)
			if self.stayOnGround and direction.Y > 0 then
				direction = Vector3.new(direction.X, 0, direction.Z).Unit
			end
		end

		humanoidRootPart.Velocity = direction * request.speed

		if (humanoidRootPart.Position - self.targetPosition).Magnitude < 1 then
			humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
			self.connection:Disconnect()
			self.connection = nil
			table.remove(self.queue, 1)
			self.onDestinationReached:Fire()

			if #self.queue > 0 then
				self:ProcessQueue()
			end
		end
	end

	self.connection = RunService.RenderStepped:Connect(onStep)
end

function TeleportSystem:Cancel()
	if self.connection then
		self.connection:Disconnect()
		self.connection = nil
		local humanoidRootPart = game.Players.LocalPlayer.Character:WaitForChild("HumanoidRootPart")
		humanoidRootPart.Velocity = Vector3.new(0, 0, 0)

		table.remove(self.queue, 1)

		if #self.queue > 0 then
			self:ProcessQueue()
		end
	end
end

return TeleportSystem
