local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

local RAYCAST_OFFSET = 1
local MINIMUM_OBSTACLE_HEIGHT = 2
local MAX_RAY_DISTANCE = 50
local MIN_HEIGHT_FOR_JUMP = 6
local MAX_HEIGHT_FOR_JUMP = 32
local WAYPOINT_SIZE = Vector3.new(0.5, 0.5, 0.5)
local WAYPOINT_COLOR = Color3.new(0, 1, 0)

function TeleportSystem.new()
	local self = setmetatable({}, TeleportSystem)
	self.queue = {}
	self.isTeleporting = false
	self.currentConnection = nil
	self.waypoints = {}
	self.onDestinationReached = Instance.new("BindableEvent")
	return self
end

function TeleportSystem:CreateWaypoint(position)
	local waypoint = Instance.new("Part")
	waypoint.Size = WAYPOINT_SIZE
	waypoint.Position = position
	waypoint.Anchored = true
	waypoint.CanCollide = false
	waypoint.BrickColor = BrickColor.new(WAYPOINT_COLOR)
	waypoint.Parent = workspace
	table.insert(self.waypoints, waypoint)
end

function TeleportSystem:ClearWaypoints()
	for _, waypoint in ipairs(self.waypoints) do
		waypoint:Destroy()
	end
	self.waypoints = {}
end

function TeleportSystem:CheckForObstacles(position, target)
	local direction = (target - position).Unit
	local ray = Ray.new(position, direction * (target - position).Magnitude)
	local hit, hitPos = workspace:FindPartOnRayWithIgnoreList(ray, {workspace.CurrentCamera})

	if hit then
		local hitSizeY = hit.Size.Y

		if hitSizeY > MIN_HEIGHT_FOR_JUMP and hitSizeY < MAX_HEIGHT_FOR_JUMP then
			return Vector3.new(hitPos.X, hitPos.Y + hitSizeY/2 + 1, hitPos.Z)
		end

		local side1 = (direction + Vector3.new(0, 0, 1)).Unit
		local side2 = (direction + Vector3.new(0, 0, -1)).Unit

		local ray1 = Ray.new(position, side1 * MAX_RAY_DISTANCE)
		local ray2 = Ray.new(position, side2 * MAX_RAY_DISTANCE)

		local hit1, hitPos1 = workspace:FindPartOnRayWithIgnoreList(ray1, {workspace.CurrentCamera})
		local hit2, hitPos2 = workspace:FindPartOnRayWithIgnoreList(ray2, {workspace.CurrentCamera})

		if hit1 and hit2 then
			if (hitPos1 - position).Magnitude > (hitPos2 - position).Magnitude then
				return hitPos1
			else
				return hitPos2
			end
		elseif hit1 then
			return hitPos1
		else
			return hitPos2
		end
	end
	return target
end

function TeleportSystem:TeleportTo(position, speed, stayOnGround)
	table.insert(self.queue, {position, speed, stayOnGround})
	if not self.isTeleporting then
		self:ProcessQueue()
	end
end

function TeleportSystem:ProcessQueue()
	self:ClearWaypoints()

	if #self.queue == 0 then
		return
	end

	local data = table.remove(self.queue, 1)
	local position, speed, stayOnGround = unpack(data)
	self.isTeleporting = true

	local character = game.Players.LocalPlayer.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	local direction = (position - humanoidRootPart.Position).Unit
	local desiredEndPos = position
	if stayOnGround then
		desiredEndPos = Vector3.new(position.X, humanoidRootPart.Position.Y, position.Z)
	end

	local previousPosition = humanoidRootPart.Position

	self.currentConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
		local moveAmount = speed * dt
		local currentPos = humanoidRootPart.Position
		local distanceToTarget = (desiredEndPos - currentPos).Magnitude
		moveAmount = math.min(moveAmount, distanceToTarget)

		local nextPosition = humanoidRootPart.Position + direction * moveAmount

		if distanceToTarget <= 1 then
			self.isTeleporting = false
			if self.currentConnection then
				self.currentConnection:Disconnect()
				self.currentConnection = nil
			end
			self.onDestinationReached:Fire()
			self:ProcessQueue()
		else
			if (nextPosition - previousPosition).Magnitude < 0.1 then
				local alternatePos = self:CheckForObstacles(nextPosition, desiredEndPos)
				direction = (alternatePos - nextPosition).Unit
				nextPosition = nextPosition + direction * moveAmount
			else
				nextPosition = nextPosition + direction * moveAmount
				previousPosition = nextPosition
			end

			if stayOnGround then
				nextPosition = Vector3.new(nextPosition.X, humanoidRootPart.Position.Y, nextPosition.Z)
			end

			self:CreateWaypoint(nextPosition)
			humanoidRootPart.CFrame = CFrame.new(nextPosition)
		end
	end)
end

function TeleportSystem:Cancel()
	if self.currentConnection then
		self.currentConnection:Disconnect()
		self.currentConnection = nil
	end
	self.isTeleporting = false
	self.queue = {}
	self:ClearWaypoints()
end

return TeleportSystem
