local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

local RAYCAST_DISTANCE = 25
local MAX_RETRIES = 3
local HEIGHT_JUMP = 10
local wallFollowDistance = 3
local wallFollowTimeLimit = 10

function TeleportSystem.new()
	local self = setmetatable({}, TeleportSystem)
	self.queue = {}
	self.isTeleporting = false
	self.currentConnection = nil
	self.onDestinationReached = Instance.new("BindableEvent")
	self.retryCount = 0
	self.lastPosition = Vector3.new()
	return self
end

function TeleportSystem:StartWallFollowing(currentPosition, targetPosition)
	local direction = (targetPosition - currentPosition).Unit
	local leftRay = Ray.new(currentPosition, CFrame.fromEulerAnglesXYZ(0, math.rad(-30), 0) * direction * RAYCAST_DISTANCE)
	local rightRay = Ray.new(currentPosition, CFrame.fromEulerAnglesXYZ(0, math.rad(30), 0) * direction * RAYCAST_DISTANCE)

	local hitLeft = workspace:FindPartOnRay(leftRay)
	local hitRight = workspace:FindPartOnRay(rightRay)

	local followDirection = hitLeft and "left" or "right"

	local startTime = tick()
	local startFollowPosition = currentPosition

	return function(humanoidRootPart, dt)
		if tick() - startTime > wallFollowTimeLimit or (humanoidRootPart.Position - startFollowPosition).Magnitude < 2 then
			return false
		end

		local sideOffset = (followDirection == "left") and math.rad(-90) or math.rad(90)
		local sideDirection = CFrame.fromEulerAnglesXYZ(0, sideOffset, 0) * direction
		local sideRay = Ray.new(humanoidRootPart.Position, sideDirection * wallFollowDistance * 2)
		local hit, hitPosition = workspace:FindPartOnRay(sideRay)

		if hit then
			local distanceToWall = (hitPosition - humanoidRootPart.Position).Magnitude
			local moveDirection = (wallFollowDistance - distanceToWall) * sideDirection
			humanoidRootPart.Velocity = moveDirection
		else
			return false
		end

		return true
	end
end

function TeleportSystem:FindBestPath(currentPosition, targetPosition)
	local direction = (targetPosition - currentPosition).Unit
	local ray = Ray.new(currentPosition, direction * RAYCAST_DISTANCE)
	local hit, hitPosition = workspace:FindPartOnRay(ray)

	if not hit then
		return direction
	else
		return self:StartWallFollowing(currentPosition, targetPosition)
	end
end

function TeleportSystem:TeleportTo(position, speed)
	table.insert(self.queue, {position, speed})
	if not self.isTeleporting then
		self:ProcessQueue()
	end
end

function TeleportSystem:ProcessQueue()
	if #self.queue == 0 then
		return
	end

	local data = table.remove(self.queue, 1)
	local position, speed = unpack(data)
	self.isTeleporting = true

	local character = game.Players.LocalPlayer.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	local wallFollowingFunction = nil

	self.currentConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
		if not wallFollowingFunction then
			local direction = self:FindBestPath(humanoidRootPart.Position, position)
			if type(direction) == "function" then
				wallFollowingFunction = direction
			else
				humanoidRootPart.Velocity = direction * speed
			end
		else
			local continueWallFollowing = wallFollowingFunction(humanoidRootPart, dt)
			if not continueWallFollowing then
				wallFollowingFunction = nil
			end
		end

		if (humanoidRootPart.Position - position).Magnitude < 1 then
			self.isTeleporting = false
			self.currentConnection:Disconnect()
			self.currentConnection = nil
			self.onDestinationReached:Fire()
		end
	end)
end

function TeleportSystem:Cancel()
	if self.currentConnection then
		self.currentConnection:Disconnect()
		self.currentConnection = nil
	end
	self.isTeleporting = false
	self.queue = {}
end

return TeleportSystem
