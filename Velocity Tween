local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

local PathfindingService = game:GetService("PathfindingService")
local RAYCAST_DISTANCE = 50
local RAYCAST_ANGLES = {-45, -30, -15, 15, 30, 45}

function TeleportSystem.new()
	local self = setmetatable({}, TeleportSystem)
	self.queue = {}
	self.isTeleporting = false
	self.currentConnection = nil
	self.onDestinationReached = Instance.new("BindableEvent")
	self.retryCount = 0
	self.lastPosition = Vector3.new()
	return self
end

function TeleportSystem:ProbeAroundObstacle(position, targetPosition)
	local bestDirection = nil
	local smallestDistanceToTarget = math.huge
	local probeDistances = {5, 10, 15, 20}

	local verticalRay = Ray.new(position, Vector3.new(0, 50, 0))
	local hit, hitPosition = workspace:FindPartOnRay(verticalRay)
	if not hit or (hitPosition - position).Y < 50 then
		return Vector3.new(0, 1, 0)
	end

	for _, distance in ipairs(probeDistances) do
		for _, angle in ipairs(RAYCAST_ANGLES) do
			local direction = (targetPosition - position).Unit
			local newDirection = CFrame.fromEulerAnglesXYZ(0, math.rad(angle), 0) * direction
			local ray = Ray.new(position, newDirection * distance)
			local hit = workspace:FindPartOnRay(ray)

			if not hit then
				local probeEndPosition = position + newDirection * distance
				local distanceToTarget = (targetPosition - probeEndPosition).Magnitude
				if distanceToTarget < smallestDistanceToTarget then
					smallestDistanceToTarget = distanceToTarget
					bestDirection = newDirection
				end
			end
		end
	end

	return bestDirection
end

function TeleportSystem:CalculateDynamicPath(startPos, endPos)
	local waypoints = {endPos}
	local currentPosition = startPos

	while (currentPosition - endPos).Magnitude > 1 do
		local direction = (endPos - currentPosition).Unit
		local ray = Ray.new(currentPosition, direction * RAYCAST_DISTANCE)
		local hit, hitPosition = workspace:FindPartOnRay(ray)

		if hit then
			local bestDirection = self:ProbeAroundObstacle(hitPosition, endPos)
			if bestDirection then
				local newWaypoint = hitPosition + bestDirection * 5
				table.insert(waypoints, 1, newWaypoint)
				currentPosition = newWaypoint
			else
				break
			end
		else
			currentPosition = currentPosition + direction * 5
		end
	end

	return waypoints
end

function TeleportSystem:TeleportTo(position, speed)
	table.insert(self.queue, {position, speed})
	if not self.isTeleporting then
		self:ProcessQueue()
	end
end

function TeleportSystem:ProcessQueue()
	if #self.queue == 0 then
		return
	end

	local data = table.remove(self.queue, 1)
	local position, speed = unpack(data)
	self.isTeleporting = true

	local character = game.Players.LocalPlayer.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	local waypoints = self:CalculateDynamicPath(humanoidRootPart.Position, position)
	local currentWaypointIndex = 1

	self.currentConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
		if currentWaypointIndex > #waypoints then
			self.isTeleporting = false
			self.currentConnection:Disconnect()
			self.currentConnection = nil
			self.onDestinationReached:Fire()
			self:ProcessQueue()
			return
		end

		local waypoint = waypoints[currentWaypointIndex]
		local direction = (waypoint - humanoidRootPart.Position).Unit
		humanoidRootPart.Velocity = direction * speed

		if (humanoidRootPart.Position - waypoint).Magnitude < 1 then
			currentWaypointIndex = currentWaypointIndex + 1
		end
	end)
end

function TeleportSystem:Cancel()
	if self.currentConnection then
		self.currentConnection:Disconnect()
		self.currentConnection = nil
	end
	self.isTeleporting = false
	self.queue = {}
end

return TeleportSystem
