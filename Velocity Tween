local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

local RAYCAST_DISTANCE = 50
local HEIGHT_JUMP = 10
local recentObstacles = {}
local backtracking = false

function TeleportSystem.new()
	local self = setmetatable({}, TeleportSystem)
	self.queue = {}
	self.isTeleporting = false
	self.currentConnection = nil
	self.onDestinationReached = Instance.new("BindableEvent")
	self.retryCount = 0
	self.lastPosition = Vector3.new()
	return self
end

function TeleportSystem:FindBestPath(currentPosition, targetPosition)
	local direction = (targetPosition - currentPosition).Unit
	local ray = Ray.new(currentPosition, direction * RAYCAST_DISTANCE)
	local hit, hitPosition = workspace:FindPartOnRay(ray)

	if not hit then
		return direction
	else
		if recentObstacles[hit] then
			recentObstacles[hit] = recentObstacles[hit] + 1
		else
			recentObstacles[hit] = 1
		end

		if recentObstacles[hit] > 3 then
			backtracking = true
		end

		if backtracking then
			return -direction
		end

		local obstacleOrientation = hit.Orientation
		local adjustedAngles = {obstacleOrientation.X, obstacleOrientation.X + 45, obstacleOrientation.X - 45}

		local bestDirection = nil
		local smallestDistanceToTarget = math.huge

		for _, angle in ipairs(adjustedAngles) do
			local newDirection = CFrame.fromEulerAnglesXYZ(0, math.rad(angle), 0) * direction
			local secondaryRay = Ray.new(currentPosition, newDirection * RAYCAST_DISTANCE)
			local secondaryHit, secondaryHitPosition = workspace:FindPartOnRay(secondaryRay)

			if not secondaryHit then
				local distanceToTargetFromHit = (targetPosition - secondaryHitPosition).Magnitude
				if distanceToTargetFromHit < smallestDistanceToTarget then
					smallestDistanceToTarget = distanceToTargetFromHit
					bestDirection = newDirection
				end
			end
		end

		if not bestDirection then
			local verticalRayUp = Ray.new(currentPosition, Vector3.new(0, HEIGHT_JUMP, 0))
			local hitUp = workspace:FindPartOnRay(verticalRayUp)

			local verticalRayDown = Ray.new(currentPosition, Vector3.new(0, -HEIGHT_JUMP, 0))
			local hitDown = workspace:FindPartOnRay(verticalRayDown)

			if not hitUp then
				bestDirection = Vector3.new(0, HEIGHT_JUMP, 0).Unit
			elseif not hitDown then
				bestDirection = Vector3.new(0, -HEIGHT_JUMP, 0).Unit
			end
		end

		return bestDirection or direction
	end
end

function TeleportSystem:TeleportTo(position, speed)
	table.insert(self.queue, {position, speed})
	if not self.isTeleporting then
		self:ProcessQueue()
	end
end

function TeleportSystem:ProcessQueue()
	if #self.queue == 0 then
		return
	end

	local data = table.remove(self.queue, 1)
	local position, speed = unpack(data)
	self.isTeleporting = true

	local character = game.Players.LocalPlayer.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	self.currentConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
		local direction = self:FindBestPath(humanoidRootPart.Position, position)
		humanoidRootPart.Velocity = direction * speed

		if (humanoidRootPart.Position - position).Magnitude < 1 then
			self.isTeleporting = false
			self.currentConnection:Disconnect()
			self.currentConnection = nil
			self.onDestinationReached:Fire()
		end
	end)
end

function TeleportSystem:Cancel()
	if self.currentConnection then
		self.currentConnection:Disconnect()
		self.currentConnection = nil
	end
	self.isTeleporting = false
	self.queue = {}
end

return TeleportSystem
