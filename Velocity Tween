local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

local RAYCAST_OFFSET = 1
local MINIMUM_OBSTACLE_HEIGHT = 2

function TeleportSystem.new()
	local self = setmetatable({}, TeleportSystem)
	self.queue = {}
	self.isTeleporting = false
	self.currentConnection = nil
	self.onDestinationReached = Instance.new("BindableEvent")
	return self
end

function TeleportSystem:TeleportTo(position, speed, stayOnGround)
	table.insert(self.queue, {position, speed, stayOnGround})
	if not self.isTeleporting then
		self:ProcessQueue()
	end
end

function TeleportSystem:ProcessQueue()
	if #self.queue == 0 then
		return
	end

	local data = table.remove(self.queue, 1)
	local position, speed, stayOnGround = unpack(data)
	self.isTeleporting = true

	local character = game.Players.LocalPlayer.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	local direction = (position - humanoidRootPart.Position).Unit
	local desiredEndPos = position
	if stayOnGround then
		desiredEndPos = Vector3.new(position.X, humanoidRootPart.Position.Y, position.Z)
	end

	local rayStart = humanoidRootPart.Position + Vector3.new(0, RAYCAST_OFFSET, 0)
	local ray = Ray.new(rayStart, direction * (humanoidRootPart.Position - desiredEndPos).Magnitude)
	local hit, _ = workspace:FindPartOnRay(ray)

	if hit and hit.Size.Y < MINIMUM_OBSTACLE_HEIGHT then
		hit = nil
	end

	local moveDirection = hit and (hit.Position - humanoidRootPart.Position).Unit or direction

	self.currentConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
		local currentPos = humanoidRootPart.Position
		local distanceToTarget = (desiredEndPos - currentPos).Magnitude
		local moveAmount = math.min(speed * dt, distanceToTarget)

		if distanceToTarget <= 1 then
			self.isTeleporting = false
			if self.currentConnection then
				self.currentConnection:Disconnect()
				self.currentConnection = nil
			end
			self.onDestinationReached:Fire()
			self:ProcessQueue()
		else
			humanoidRootPart.CFrame = CFrame.new(currentPos + moveDirection * moveAmount)
		end
	end)
end

function TeleportSystem:Cancel()
	if self.currentConnection then
		self.currentConnection:Disconnect()
		self.currentConnection = nil
	end
	self.isTeleporting = false
	self.queue = {}
end

return TeleportSystem
