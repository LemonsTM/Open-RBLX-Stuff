local TeleportSystem = {}
TeleportSystem.__index = TeleportSystem

local RAYCAST_OFFSET = 1
local RAYCAST_DISTANCE = 50
local RAYCAST_ANGLES = {-90, -75, -60, -45, -30, -15, 0, 15, 30, 45, 60, 75, 90}
local MAX_RETRIES = 3
local HEIGHT_JUMP = 10
local MIN_DISTANCE_MOVED = 0.5
local SAFETY_CHECKPOINT_DISTANCE = 5

function TeleportSystem.new()
	local self = setmetatable({}, TeleportSystem)
	self.queue = {}
	self.isTeleporting = false
	self.currentConnection = nil
	self.onDestinationReached = Instance.new("BindableEvent")
	self.retryCount = 0
	self.lastPosition = Vector3.new()
	return self
end

function TeleportSystem:FindBestPath(currentPosition, targetPosition)
	local direction = (targetPosition - currentPosition).Unit
	local smallestDistanceToTarget = math.huge
	local bestDirection = direction

	for _, angle in ipairs(RAYCAST_ANGLES) do
		local newDirection = CFrame.fromEulerAnglesXYZ(0, math.rad(angle), 0) * direction
		local ray = Ray.new(currentPosition + Vector3.new(0, RAYCAST_OFFSET, 0), newDirection * RAYCAST_DISTANCE)
		local hit, hitPosition = workspace:FindPartOnRay(ray)

		if hit then
			local distanceToTargetFromHit = (targetPosition - hitPosition).Magnitude
			if distanceToTargetFromHit < smallestDistanceToTarget then
				smallestDistanceToTarget = distanceToTargetFromHit
				bestDirection = newDirection
			end
		end
	end

	if bestDirection == direction then
		local verticalRay = Ray.new(currentPosition, Vector3.new(0, HEIGHT_JUMP, 0))
		local hit, _ = workspace:FindPartOnRay(verticalRay)
		if not hit then
			bestDirection = Vector3.new(0, HEIGHT_JUMP, 0).Unit
		end
	end

	return bestDirection
end

function TeleportSystem:SteerAwayFromObstacles(currentPosition, desiredDirection)
	local avoidanceVector = Vector3.new()
	for _, angle in ipairs(RAYCAST_ANGLES) do
		local rayDirection = CFrame.fromEulerAnglesXYZ(0, math.rad(angle), 0) * desiredDirection
		local ray = Ray.new(currentPosition + Vector3.new(0, RAYCAST_OFFSET, 0), rayDirection * RAYCAST_DISTANCE)
		local hit, _ = workspace:FindPartOnRay(ray)
		if hit then
			avoidanceVector = avoidanceVector - rayDirection
		end
	end
	return (desiredDirection + avoidanceVector).Unit
end

function TeleportSystem:ProcessQueue()
	if #self.queue == 0 then
		return
	end

	local data = table.remove(self.queue, 1)
	local position, speed, stayOnGround = unpack(data)
	self.isTeleporting = true

	local character = game.Players.LocalPlayer.Character
	local humanoidRootPart = character and character:FindFirstChild("HumanoidRootPart")
	if not humanoidRootPart then return end

	local desiredEndPos = position
	if stayOnGround then
		desiredEndPos = Vector3.new(position.X, humanoidRootPart.Position.Y, position.Z)
	end

	local direction = (desiredEndPos - humanoidRootPart.Position).Unit
	local currentVelocity = Vector3.new(0, 0, 0)
	local acceleration = speed * 2

	self.currentConnection = game:GetService("RunService").RenderStepped:Connect(function(dt)
		local currentPos = humanoidRootPart.Position
		local distanceToTarget = (desiredEndPos - currentPos).Magnitude

		local steerDirection = self:SteerAwayFromObstacles(currentPos, direction).Unit

		local desiredVelocity = steerDirection * speed
		currentVelocity = currentVelocity + steerDirection * acceleration * dt
		if currentVelocity.Magnitude > desiredVelocity.Magnitude then
			currentVelocity = desiredVelocity
		end
		humanoidRootPart.Velocity = currentVelocity

		if distanceToTarget <= 1 then
			self.isTeleporting = false
			humanoidRootPart.Velocity = Vector3.new(0, 0, 0)
			if self.currentConnection then
				self.currentConnection:Disconnect()
				self.currentConnection = nil
			end
			self.onDestinationReached:Fire()
			self:ProcessQueue()
			self.retryCount = 0
			self.lastPosition = currentPos
		end
	end)
end

function TeleportSystem:TeleportTo(position, speed, stayOnGround)
	table.insert(self.queue, {position, speed, stayOnGround})
	if not self.isTeleporting then
		self:ProcessQueue()
	end
end

function TeleportSystem:Cancel()
	if self.currentConnection then
		self.currentConnection:Disconnect()
		self.currentConnection = nil
	end
	self.isTeleporting = false
	self.queue = {}
end

return TeleportSystem
